; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S -passes=newgvn < %s | FileCheck %s

; Make sure we don't have use-after-free due to dangling values in
; select available value.

define i64 @test(i1 %c, ptr %p) {
; CHECK-LABEL: define i64 @test(
; CHECK-SAME: i1 [[C:%.*]], ptr [[P:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    br i1 true, label %[[LOOP_EXIT_CRIT_EDGE:.*]], label %[[LOOP_CONT:.*]]
; CHECK:       [[LOOP_EXIT_CRIT_EDGE]]:
; CHECK-NEXT:    br label %[[EXIT:.*]]
; CHECK:       [[LOOP_CONT]]:
; CHECK-NEXT:    store i8 poison, ptr null, align 1
; CHECK-NEXT:    br i1 [[C]], label %[[LOOP_CONT_EXIT_CRIT_EDGE:.*]], label %[[LOOP_LATCH:.*]]
; CHECK:       [[LOOP_CONT_EXIT_CRIT_EDGE]]:
; CHECK-NEXT:    store i8 poison, ptr null, align 1
; CHECK-NEXT:    br label %[[EXIT]]
; CHECK:       [[LOOP_LATCH]]:
; CHECK-NEXT:    store i8 poison, ptr null, align 1
; CHECK-NEXT:    br label %[[LOOP]]
; CHECK:       [[EXIT]]:
; CHECK-NEXT:    [[LOAD6:%.*]] = load i64, ptr [[P]], align 8
; CHECK-NEXT:    ret i64 [[LOAD6]]
;
entry:
  br label %loop

loop:
  %iv = phi i64 [ 0, %entry ], [ %add, %loop.latch ]
  %ptr.iv = phi ptr [ %p, %entry ], [ %select, %loop.latch ]
  %icmp = icmp eq i64 %iv, 0
  br i1 %icmp, label %exit, label %loop.cont

loop.cont:
  %add = add i64 %iv, -1
  br i1 %c, label %exit, label %loop.latch

loop.latch:
  %load = load i64, ptr %ptr.iv, align 8
  %load6 = load i64, ptr %p, align 8
  %icmp7 = icmp ugt i64 %load, %load6
  %select = select i1 %icmp7, ptr %ptr.iv, ptr %p
  br label %loop

exit:
  %res = load i64, ptr %ptr.iv, align 8
  ret i64 %res
}
