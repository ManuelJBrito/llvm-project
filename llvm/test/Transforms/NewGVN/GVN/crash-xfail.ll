; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -passes=newgvn -S < %s | FileCheck %s
; XFAIL: *
; PR5631

target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64"
target triple = "x86_64-apple-darwin10.0"

define ptr @test1(ptr %name, i32 %namelen, ptr %o, i32 %expected_type, i1 %arg) nounwind ssp {
; CHECK-LABEL: define ptr @test1(
; CHECK-SAME: ptr [[NAME:%.*]], i32 [[NAMELEN:%.*]], ptr [[O:%.*]], i32 [[EXPECTED_TYPE:%.*]], i1 [[ARG:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br i1 [[ARG]], label %[[IF_END13:.*]], label %[[WHILE_BODY_PREHEADER:.*]]
; CHECK:       [[IF_END13]]:
; CHECK-NEXT:    br label %[[WHILE_BODY_PREHEADER]]
; CHECK:       [[WHILE_BODY_PREHEADER]]:
; CHECK-NEXT:    br label %[[WHILE_BODY:.*]]
; CHECK:       [[WHILE_BODY]]:
; CHECK-NEXT:    br i1 false, label %[[WHILE_BODY_RETURN_LOOPEXIT_CRIT_EDGE:.*]], label %[[LOR_LHS_FALSE:.*]]
; CHECK:       [[WHILE_BODY_RETURN_LOOPEXIT_CRIT_EDGE]]:
; CHECK-NEXT:    br label %[[RETURN_LOOPEXIT:.*]]
; CHECK:       [[LOR_LHS_FALSE]]:
; CHECK-NEXT:    br i1 [[ARG]], label %[[LAND_LHS_TRUE24:.*]], label %[[IF_END31:.*]]
; CHECK:       [[LAND_LHS_TRUE24]]:
; CHECK-NEXT:    [[CALL28:%.*]] = call ptr @parse_object(ptr undef) #[[ATTR1:[0-9]+]]
; CHECK-NEXT:    br i1 true, label %[[RETURN_LOOPEXITSPLIT:.*]], label %[[LAND_LHS_TRUE24_IF_END31_CRIT_EDGE:.*]]
; CHECK:       [[LAND_LHS_TRUE24_IF_END31_CRIT_EDGE]]:
; CHECK-NEXT:    br label %[[IF_END31]]
; CHECK:       [[IF_END31]]:
; CHECK-NEXT:    br i1 [[ARG]], label %[[RETURN_LOOPEXITSPLIT]], label %[[IF_END41:.*]]
; CHECK:       [[IF_END41]]:
; CHECK-NEXT:    br i1 false, label %[[IF_THEN50:.*]], label %[[IF_ELSE:.*]]
; CHECK:       [[IF_THEN50]]:
; CHECK-NEXT:    [[TMP53:%.*]] = load ptr, ptr undef, align 8
; CHECK-NEXT:    br label %[[WHILE_BODY_BACKEDGE:.*]]
; CHECK:       [[IF_ELSE]]:
; CHECK-NEXT:    br i1 false, label %[[IF_THEN62:.*]], label %[[IF_ELSE67:.*]]
; CHECK:       [[IF_THEN62]]:
; CHECK-NEXT:    br label %[[WHILE_BODY_BACKEDGE]]
; CHECK:       [[WHILE_BODY_BACKEDGE]]:
; CHECK-NEXT:    [[O_ADDR_0_BE:%.*]] = phi ptr [ poison, %[[IF_THEN50]] ], [ undef, %[[IF_THEN62]] ]
; CHECK-NEXT:    br label %[[WHILE_BODY]]
; CHECK:       [[IF_ELSE67]]:
; CHECK-NEXT:    ret ptr null
; CHECK:       [[RETURN_LOOPEXITSPLIT]]:
; CHECK-NEXT:    br label %[[RETURN_LOOPEXIT]]
; CHECK:       [[RETURN_LOOPEXIT]]:
; CHECK-NEXT:    ret ptr undef
;
entry:
  br i1 %arg, label %if.end13, label %while.body.preheader


if.end13:                                         ; preds = %if.then6
  br label %while.body.preheader

while.body.preheader:                             ; preds = %if.end13, %if.end
  br label %while.body

while.body:                                       ; preds = %while.body.backedge, %while.body.preheader
  %o.addr.0 = phi ptr [ undef, %while.body.preheader ], [ %o.addr.0.be, %while.body.backedge ] ; <ptr> [#uses=2]
  br i1 false, label %return.loopexit, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %tmp22 = load i32, ptr %o.addr.0                       ; <i32> [#uses=0]
  br i1 %arg, label %land.lhs.true24, label %if.end31

land.lhs.true24:                                  ; preds = %lor.lhs.false
  %call28 = call ptr @parse_object(ptr undef) nounwind ; <ptr> [#uses=0]
  br i1 %arg, label %return.loopexit, label %if.end31

if.end31:                                         ; preds = %land.lhs.true24, %lor.lhs.false
  br i1 %arg, label %return.loopexit, label %if.end41

if.end41:                                         ; preds = %if.end31
  %tmp45 = load i32, ptr %o.addr.0                       ; <i32> [#uses=0]
  br i1 %arg, label %if.then50, label %if.else

if.then50:                                        ; preds = %if.end41
  %tmp53 = load ptr, ptr undef                       ; <ptr> [#uses=1]
  br label %while.body.backedge

if.else:                                          ; preds = %if.end41
  br i1 %arg, label %if.then62, label %if.else67

if.then62:                                        ; preds = %if.else
  br label %while.body.backedge

while.body.backedge:                              ; preds = %if.then62, %if.then50
  %o.addr.0.be = phi ptr [ %tmp53, %if.then50 ], [ undef, %if.then62 ] ; <ptr> [#uses=1]
  br label %while.body

if.else67:                                        ; preds = %if.else
  ret ptr null

return.loopexit:                                  ; preds = %if.end31, %land.lhs.true24, %while.body
  ret ptr undef
}

declare ptr @parse_object(ptr)






%struct.attribute_spec = type { ptr, i32, i32, i8, i8, i8 }

@attribute_tables = external global [4 x ptr] ; <ptr> [#uses=2]

define void @test2() nounwind {
; CHECK-LABEL: define void @test2(
; CHECK-SAME: ) #[[ATTR1]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[BB69_I:.*]]
; CHECK:       [[BB69_I]]:
; CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr @attribute_tables, align 4
; CHECK-NEXT:    br label %[[BB65_I:.*]]
; CHECK:       [[BB65_I]]:
; CHECK-NEXT:    [[STOREMERGE6_I:%.*]] = phi i32 [ 1, %[[BB64_I:.*]] ], [ 0, %[[BB69_I]] ]
; CHECK-NEXT:    [[SCEVGEP14:%.*]] = getelementptr inbounds [[STRUCT_ATTRIBUTE_SPEC:%.*]], ptr [[TMP3]], i32 [[STOREMERGE6_I]], i32 0
; CHECK-NEXT:    unreachable
; CHECK:       [[BB64_I]]:
; CHECK-NEXT:    br label %[[BB65_I]]
; CHECK:       [[BB66_I:.*:]]
; CHECK-NEXT:    br label %[[BB69_I]]
;
entry:
  br label %bb69.i

bb69.i:                                           ; preds = %bb57.i.preheader
  %tmp4 = getelementptr inbounds [4 x ptr], ptr @attribute_tables, i32 0, i32 undef ; <ptr> [#uses=1]
  %tmp3 = load ptr, ptr %tmp4, align 4 ; <ptr> [#uses=1]
  br label %bb65.i

bb65.i:                                           ; preds = %bb65.i.preheader, %bb64.i
  %storemerge6.i = phi i32 [ 1, %bb64.i ], [ 0, %bb69.i ] ; <i32> [#uses=3]
  %scevgep14 = getelementptr inbounds %struct.attribute_spec, ptr %tmp3, i32 %storemerge6.i, i32 0 ; <ptr> [#uses=1]
  %tmp2 = load ptr, ptr %scevgep14, align 4           ; <ptr> [#uses=0]
  %tmp = load ptr, ptr %tmp4, align 4 ; <ptr> [#uses=1]
  %scevgep1516 = getelementptr inbounds %struct.attribute_spec, ptr %tmp, i32 %storemerge6.i, i32 0 ; <ptr> [#uses=0]
  unreachable

bb64.i:                                           ; Unreachable
  br label %bb65.i

bb66.i:                                           ; Unreachable
  br label %bb69.i
}



; rdar://7438974

@g = external global i64, align 8

define ptr @test3(i1 %arg) {
; CHECK-LABEL: define ptr @test3(
; CHECK-SAME: i1 [[ARG:%.*]]) {
; CHECK-NEXT:  [[DO_END17_I:.*:]]
; CHECK-NEXT:    [[TMP18_I:%.*]] = load ptr, ptr undef, align 8
; CHECK-NEXT:    br i1 [[ARG]], label %[[DO_BODY36_I:.*]], label %[[IF_THEN21_I:.*]]
; CHECK:       [[IF_THEN21_I]]:
; CHECK-NEXT:    ret ptr undef
; CHECK:       [[DO_BODY36_I]]:
; CHECK-NEXT:    [[IVAR38_I:%.*]] = load i64, ptr @g, align 8
; CHECK-NEXT:    [[ADD_PTR39_SUM_I:%.*]] = add i64 [[IVAR38_I]], 8
; CHECK-NEXT:    [[TMP40_I:%.*]] = getelementptr inbounds i8, ptr [[TMP18_I]], i64 [[ADD_PTR39_SUM_I]]
; CHECK-NEXT:    br i1 true, label %[[IF_THEN48_I:.*]], label %[[DO_BODY36_I_DO_BODY57_I_CRIT_EDGE:.*]]
; CHECK:       [[DO_BODY36_I_DO_BODY57_I_CRIT_EDGE]]:
; CHECK-NEXT:    br label %[[DO_BODY57_I:.*]]
; CHECK:       [[IF_THEN48_I]]:
; CHECK-NEXT:    [[CALL54_I:%.*]] = call i32 @foo2()
; CHECK-NEXT:    [[IVAR59_I_PRE:%.*]] = load i64, ptr @g, align 8
; CHECK-NEXT:    [[DOTPRE:%.*]] = add i64 [[IVAR59_I_PRE]], 8
; CHECK-NEXT:    br label %[[DO_BODY57_I]]
; CHECK:       [[DO_BODY57_I]]:
; CHECK-NEXT:    [[ADD_PTR65_SUM_I_PRE_PHI:%.*]] = phi i64 [ [[ADD_PTR39_SUM_I]], %[[DO_BODY36_I_DO_BODY57_I_CRIT_EDGE]] ], [ [[DOTPRE]], %[[IF_THEN48_I]] ]
; CHECK-NEXT:    [[IVAR59_I:%.*]] = phi i64 [ [[IVAR38_I]], %[[DO_BODY36_I_DO_BODY57_I_CRIT_EDGE]] ], [ [[IVAR59_I_PRE]], %[[IF_THEN48_I]] ]
; CHECK-NEXT:    [[TMP58_I:%.*]] = load ptr, ptr undef, align 8
; CHECK-NEXT:    [[TMP66_I:%.*]] = getelementptr inbounds i8, ptr [[TMP58_I]], i64 [[ADD_PTR65_SUM_I_PRE_PHI]]
; CHECK-NEXT:    ret ptr undef
;
do.end17.i:
  %tmp18.i = load ptr, ptr undef
  br i1 %arg, label %do.body36.i, label %if.then21.i

if.then21.i:
  ret ptr undef

do.body36.i:
  %ivar38.i = load i64, ptr @g
  %add.ptr39.sum.i = add i64 %ivar38.i, 8
  %tmp40.i = getelementptr inbounds i8, ptr %tmp18.i, i64 %add.ptr39.sum.i
  %tmp41.i = load i64, ptr %tmp40.i
  br i1 %arg, label %if.then48.i, label %do.body57.i

if.then48.i:
  %call54.i = call i32 @foo2()
  br label %do.body57.i

do.body57.i:
  %tmp58.i = load ptr, ptr undef
  %ivar59.i = load i64, ptr @g
  %add.ptr65.sum.i = add i64 %ivar59.i, 8
  %tmp66.i = getelementptr inbounds i8, ptr %tmp58.i, i64 %add.ptr65.sum.i
  %tmp67.i = load i64, ptr %tmp66.i
  ret ptr undef
}

declare i32 @foo2()



define i32 @test4() {
; CHECK-LABEL: define i32 @test4() {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    ret i32 0
; CHECK:       [[DEAD:.*]]:
; CHECK-NEXT:    [[P2:%.*]] = getelementptr i32, ptr [[P2]], i32 52
; CHECK-NEXT:    [[Q2:%.*]] = getelementptr i32, ptr [[Q2]], i32 52
; CHECK-NEXT:    store i32 4, ptr [[P2]], align 4
; CHECK-NEXT:    [[A:%.*]] = load i32, ptr [[Q2]], align 4
; CHECK-NEXT:    br i1 true, label %[[DEAD]], label %[[DEAD2:.*]]
; CHECK:       [[DEAD2]]:
; CHECK-NEXT:    ret i32 [[A]]
;
entry:
  ret i32 0

dead:
  %P2 = getelementptr i32, ptr %P2, i32 52
  %Q2 = getelementptr i32, ptr %Q2, i32 52
  store i32 4, ptr %P2
  %A = load i32, ptr %Q2
  br i1 true, label %dead, label %dead2

dead2:
  ret i32 %A
}


; PR9841
define fastcc i8 @test5(ptr %P) nounwind {
; CHECK-LABEL: define fastcc i8 @test5(
; CHECK-SAME: ptr [[P:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[Q:%.*]] = getelementptr i8, ptr [[P]], i32 1
; CHECK-NEXT:    [[TMP0:%.*]] = load i8, ptr [[Q]], align 1
; CHECK-NEXT:    ret i8 [[TMP0]]
;
entry:
  %0 = load i8, ptr %P, align 2

  %Q = getelementptr i8, ptr %P, i32 1
  %1 = load i8, ptr %Q, align 1
  ret i8 %1
}


; Test that a GEP in an unreachable block with the following form doesn't crash
; newgvn:
;
;    %x = gep %some.type %x, ...

%struct.type = type { i64, i32, i32 }

define fastcc void @func(i1 %arg) nounwind uwtable ssp align 2 {
; CHECK-LABEL: define fastcc void @func(
; CHECK-SAME: i1 [[ARG:%.*]]) #[[ATTR2:[0-9]+]] align 2 {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    br label %[[U2_BB:.*]]
; CHECK:       [[U1_BB:.*]]:
; CHECK-NEXT:    store i64 -1, ptr [[GEP_VAL:%.*]], align 8
; CHECK-NEXT:    [[GEP_VAL]] = getelementptr inbounds [[STRUCT_TYPE:%.*]], ptr [[GEP_VAL]], i64 1
; CHECK-NEXT:    br i1 [[ARG]], label %[[U2_BB]], label %[[U1_BB]]
; CHECK:       [[U2_BB]]:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr undef, align 4
; CHECK-NEXT:    [[CONV_I_I_I_I_I:%.*]] = zext i32 [[TMP0]] to i64
; CHECK-NEXT:    br label %[[U2_BB]]
;
entry:
  br label %reachable.bb

;; Unreachable code.

unreachable.bb:
  %gep.val = getelementptr inbounds %struct.type, ptr %gep.val, i64 1
  br i1 %arg, label %u2.bb, label %u1.bb

u1.bb:
  store i64 -1, ptr %gep.val, align 8
  br label %unreachable.bb

u2.bb:
  %0 = load i32, ptr undef, align 4
  %conv.i.i.i.i.i = zext i32 %0 to i64
  br label %u2.bb

;; Reachable code.

reachable.bb:
  br label %r1.bb

r1.bb:
  br label %u2.bb
}
