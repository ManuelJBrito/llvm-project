; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt -S < %s -passes=newgvn | FileCheck %s

declare void @llvm.sideeffect()

; Store-to-load forwarding across a @llvm.sideeffect.

define float @s2l(ptr %p) {
; CHECK-LABEL: define float @s2l(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    store float 0.000000e+00, ptr [[P]], align 4
; CHECK-NEXT:    call void @llvm.sideeffect()
; CHECK-NEXT:    ret float 0.000000e+00
;
  store float 0.0, ptr %p
  call void @llvm.sideeffect()
  %t = load float, ptr %p
  ret float %t
}

; Redundant load elimination across a @llvm.sideeffect.

define float @rle(ptr %p) {
; CHECK-LABEL: define float @rle(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    [[R:%.*]] = load float, ptr [[P]], align 4
; CHECK-NEXT:    call void @llvm.sideeffect()
; CHECK-NEXT:    [[T:%.*]] = fadd float [[R]], [[R]]
; CHECK-NEXT:    ret float [[T]]
;
  %r = load float, ptr %p
  call void @llvm.sideeffect()
  %s = load float, ptr %p
  %t = fadd float %r, %s
  ret float %t
}

; LICM across a @llvm.sideeffect.

define float @licm(i64 %n, ptr nocapture readonly %p) #0 {
; CHECK-LABEL: define float @licm(
; CHECK-SAME: i64 [[N:%.*]], ptr readonly captures(none) [[P:%.*]]) {
; CHECK-NEXT:  [[BB0:.*]]:
; CHECK-NEXT:    [[T3_PRE:%.*]] = load float, ptr [[P]], align 4
; CHECK-NEXT:    br label %[[LOOP:.*]]
; CHECK:       [[LOOP]]:
; CHECK-NEXT:    [[I:%.*]] = phi i64 [ 0, %[[BB0]] ], [ [[T5:%.*]], %[[LOOP_LOOP_CRIT_EDGE:.*]] ]
; CHECK-NEXT:    [[SUM:%.*]] = phi float [ 0.000000e+00, %[[BB0]] ], [ [[T4:%.*]], %[[LOOP_LOOP_CRIT_EDGE]] ]
; CHECK-NEXT:    call void @llvm.sideeffect()
; CHECK-NEXT:    [[T4]] = fadd float [[SUM]], [[T3_PRE]]
; CHECK-NEXT:    [[T5]] = add i64 [[I]], 1
; CHECK-NEXT:    [[T6:%.*]] = icmp ult i64 [[T5]], [[N]]
; CHECK-NEXT:    br i1 [[T6]], label %[[LOOP_LOOP_CRIT_EDGE]], label %[[BB2:.*]]
; CHECK:       [[LOOP_LOOP_CRIT_EDGE]]:
; CHECK-NEXT:    br label %[[LOOP]]
; CHECK:       [[BB2]]:
; CHECK-NEXT:    ret float [[T4]]
;
bb0:
  br label %loop

loop:
  %i = phi i64 [ 0, %bb0 ], [ %t5, %loop ]
  %sum = phi float [ 0.000000e+00, %bb0 ], [ %t4, %loop ]
  call void @llvm.sideeffect()
  %t3 = load float, ptr %p
  %t4 = fadd float %sum, %t3
  %t5 = add i64 %i, 1
  %t6 = icmp ult i64 %t5, %n
  br i1 %t6, label %loop, label %bb2

bb2:
  ret float %t4
}
