; XFAIL: *
; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt < %s -passes=newgvn -enable-pre -S | FileCheck %s

declare void @may_exit() nounwind

declare void @may_exit_1(i32) nounwind

define i32 @main(i32 %p, i32 %q) {
; CHECK-LABEL: define i32 @main(
; CHECK-SAME: i32 [[P:%.*]], i32 [[Q:%.*]]) {
; CHECK-NEXT:  block1:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[P]], [[Q]]
; CHECK-NEXT:    br i1 [[CMP]], label [[BLOCK2:%.*]], label [[BLOCK3:%.*]]
; CHECK:       block2:
; CHECK-NEXT:    [[A:%.*]] = add i32 [[P]], 1
; CHECK-NEXT:    br label [[BLOCK4:%.*]]
; CHECK:       block3:
; CHECK-NEXT:    [[DOTPRE:%.*]] = add i32 [[P]], 1
; CHECK-NEXT:    br label [[BLOCK4]]
; CHECK:       block4:
; CHECK-NEXT:    [[B_PRE_PHI:%.*]] = phi i32 [ [[DOTPRE]], [[BLOCK3]] ], [ [[A]], [[BLOCK2]] ]
; CHECK-NEXT:    ret i32 [[B_PRE_PHI]]
;

block1:
  %cmp = icmp eq i32 %p, %q
  br i1 %cmp, label %block2, label %block3

block2:
  %a = add i32 %p, 1
  br label %block4

block3:
  br label %block4

block4:
  %b = add i32 %p, 1
  ret i32 %b
}

; Don't PRE across implicit control flow.
define i32 @test2(i32 %p, i32 %q) {
; CHECK-LABEL: define i32 @test2(
; CHECK-SAME: i32 [[P:%.*]], i32 [[Q:%.*]]) {
; CHECK-NEXT:  block1:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[P]], [[Q]]
; CHECK-NEXT:    br i1 [[CMP]], label [[BLOCK2:%.*]], label [[BLOCK3:%.*]]
; CHECK:       block2:
; CHECK-NEXT:    br label [[BLOCK4:%.*]]
; CHECK:       block3:
; CHECK-NEXT:    br label [[BLOCK4]]
; CHECK:       block4:
; CHECK-NEXT:    call void @may_exit() #[[ATTR0:[0-9]+]]
; CHECK-NEXT:    [[B:%.*]] = sdiv i32 [[P]], [[Q]]
; CHECK-NEXT:    ret i32 [[B]]
;

block1:
  %cmp = icmp eq i32 %p, %q
  br i1 %cmp, label %block2, label %block3

block2:
  %a = sdiv i32 %p, %q
  br label %block4

block3:
  br label %block4


block4:
  call void @may_exit() nounwind
  %b = sdiv i32 %p, %q
  ret i32 %b
}

; Don't PRE across implicit control flow.
define i32 @test3(i32 %p, i32 %q, i1 %r) {
; CHECK-LABEL: define i32 @test3(
; CHECK-SAME: i32 [[P:%.*]], i32 [[Q:%.*]], i1 [[R:%.*]]) {
; CHECK-NEXT:  block1:
; CHECK-NEXT:    br i1 [[R]], label [[BLOCK2:%.*]], label [[BLOCK3:%.*]]
; CHECK:       block2:
; CHECK-NEXT:    [[A:%.*]] = sdiv i32 [[P]], [[Q]]
; CHECK-NEXT:    br label [[BLOCK4:%.*]]
; CHECK:       block3:
; CHECK-NEXT:    br label [[BLOCK4]]
; CHECK:       block4:
; CHECK-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[BLOCK3]] ], [ [[A]], [[BLOCK2]] ]
; CHECK-NEXT:    call void @may_exit_1(i32 [[PHI]]) #[[ATTR0]]
; CHECK-NEXT:    [[B:%.*]] = sdiv i32 [[P]], [[Q]]
; CHECK-NEXT:    ret i32 [[B]]
;

block1:
  br i1 %r, label %block2, label %block3

block2:
  %a = sdiv i32 %p, %q
  br label %block4

block3:
  br label %block4

block4:


  %phi = phi i32 [ 0, %block3 ], [ %a, %block2 ]
  call void @may_exit_1(i32 %phi) nounwind
  %b = sdiv i32 %p, %q
  ret i32 %b

}

; It's OK to PRE an instruction that is guaranteed to be safe to execute
; speculatively.
; TODO: Does it make any sense in this case?
define i32 @test4(i32 %p, i32 %q) {
; CHECK-LABEL: define i32 @test4(
; CHECK-SAME: i32 [[P:%.*]], i32 [[Q:%.*]]) {
; CHECK-NEXT:  block1:
; CHECK-NEXT:    [[CMP:%.*]] = icmp eq i32 [[P]], [[Q]]
; CHECK-NEXT:    br i1 [[CMP]], label [[BLOCK2:%.*]], label [[BLOCK3:%.*]]
; CHECK:       block2:
; CHECK-NEXT:    [[A:%.*]] = sdiv i32 [[P]], 6
; CHECK-NEXT:    br label [[BLOCK4:%.*]]
; CHECK:       block3:
; CHECK-NEXT:    [[DOTPRE:%.*]] = sdiv i32 [[P]], 6
; CHECK-NEXT:    br label [[BLOCK4]]
; CHECK:       block4:
; CHECK-NEXT:    [[B_PRE_PHI:%.*]] = phi i32 [ [[DOTPRE]], [[BLOCK3]] ], [ [[A]], [[BLOCK2]] ]
; CHECK-NEXT:    call void @may_exit() #[[ATTR0]]
; CHECK-NEXT:    ret i32 [[B_PRE_PHI]]
;

block1:
  %cmp = icmp eq i32 %p, %q
  br i1 %cmp, label %block2, label %block3

block2:
  %a = sdiv i32 %p, 6
  br label %block4

block3:
  br label %block4


block4:
  call void @may_exit() nounwind
  %b = sdiv i32 %p, 6
  ret i32 %b
}

; It is OK to PRE across implicit control flow if we don't insert new
; instructions.
define i32 @test5(i1 %cond, i32 %p, i32 %q) {
; CHECK-LABEL: define i32 @test5(
; CHECK-SAME: i1 [[COND:%.*]], i32 [[P:%.*]], i32 [[Q:%.*]]) {
; CHECK-NEXT:  block1:
; CHECK-NEXT:    br i1 [[COND]], label [[BLOCK2:%.*]], label [[BLOCK3:%.*]]
; CHECK:       block2:
; CHECK-NEXT:    [[A:%.*]] = sdiv i32 [[P]], [[Q]]
; CHECK-NEXT:    br label [[BLOCK4:%.*]]
; CHECK:       block3:
; CHECK-NEXT:    [[B:%.*]] = sdiv i32 [[P]], [[Q]]
; CHECK-NEXT:    br label [[BLOCK4]]
; CHECK:       block4:
; CHECK-NEXT:    [[C_PRE_PHI:%.*]] = phi i32 [ [[B]], [[BLOCK3]] ], [ [[A]], [[BLOCK2]] ]
; CHECK-NEXT:    call void @may_exit() #[[ATTR0]]
; CHECK-NEXT:    ret i32 [[C_PRE_PHI]]
;

block1:
  br i1 %cond, label %block2, label %block3

block2:
  %a = sdiv i32 %p, %q
  br label %block4

block3:
  %b = sdiv i32 %p, %q
  br label %block4


block4:
  call void @may_exit() nounwind
  %c = sdiv i32 %p, %q
  ret i32 %c
}
