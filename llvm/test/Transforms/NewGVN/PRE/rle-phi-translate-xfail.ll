; XFAIL: *
; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 4
; RUN: opt < %s -passes=newgvn -S | FileCheck %s

target datalayout = "e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128"
target triple = "i386-apple-darwin7"

define i32 @test1(ptr %b, ptr %c) nounwind {
; CHECK-LABEL: define i32 @test1(
; CHECK-SAME: ptr [[B:%.*]], ptr [[C:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    [[G:%.*]] = alloca i32, align 4
; CHECK-NEXT:    [[T1:%.*]] = icmp eq ptr [[B]], null
; CHECK-NEXT:    br i1 [[T1]], label [[BB:%.*]], label [[BB1:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    [[T2:%.*]] = load i32, ptr [[C]], align 4
; CHECK-NEXT:    [[T3:%.*]] = add i32 [[T2]], 1
; CHECK-NEXT:    store i32 [[T3]], ptr [[G]], align 4
; CHECK-NEXT:    br label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[T5:%.*]] = load i32, ptr [[B]], align 4
; CHECK-NEXT:    [[T6:%.*]] = add i32 [[T5]], 1
; CHECK-NEXT:    store i32 [[T6]], ptr [[G]], align 4
; CHECK-NEXT:    br label [[BB2]]
; CHECK:       bb2:
; CHECK-NEXT:    [[BV:%.*]] = phi i32 [ [[T5]], [[BB1]] ], [ [[T3]], [[BB]] ]
; CHECK-NEXT:    [[CV:%.*]] = phi i32 [ [[T6]], [[BB1]] ], [ [[T2]], [[BB]] ]
; CHECK-NEXT:    [[C_ADDR_0:%.*]] = phi ptr [ [[G]], [[BB1]] ], [ [[C]], [[BB]] ]
; CHECK-NEXT:    [[B_ADDR_0:%.*]] = phi ptr [ [[B]], [[BB1]] ], [ [[G]], [[BB]] ]
; CHECK-NEXT:    [[RET:%.*]] = add i32 [[CV]], [[BV]]
; CHECK-NEXT:    ret i32 [[RET]]
;
entry:
  %g = alloca i32
  %t1 = icmp eq ptr %b, null
  br i1 %t1, label %bb, label %bb1

bb:
  %t2 = load i32, ptr %c, align 4
  %t3 = add i32 %t2, 1
  store i32 %t3, ptr %g, align 4
  br label %bb2

bb1:		; preds = %entry
  %t5 = load i32, ptr %b, align 4
  %t6 = add i32 %t5, 1
  store i32 %t6, ptr %g, align 4
  br label %bb2

bb2:		; preds = %bb1, %bb
  %c_addr.0 = phi ptr [ %g, %bb1 ], [ %c, %bb ]
  %b_addr.0 = phi ptr [ %b, %bb1 ], [ %g, %bb ]
  %cv = load i32, ptr %c_addr.0, align 4
  %bv = load i32, ptr %b_addr.0, align 4
  %ret = add i32 %cv, %bv
  ret i32 %ret
}

define i8 @test2(i1 %cond, ptr %b, ptr %c) nounwind {
; CHECK-LABEL: define i8 @test2(
; CHECK-SAME: i1 [[COND:%.*]], ptr [[B:%.*]], ptr [[C:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[COND]], label [[BB:%.*]], label [[BB1:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    store i8 4, ptr [[B]], align 1
; CHECK-NEXT:    br label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    store i8 92, ptr [[C]], align 1
; CHECK-NEXT:    br label [[BB2]]
; CHECK:       bb2:
; CHECK-NEXT:    [[DV:%.*]] = phi i8 [ 92, [[BB1]] ], [ 4, [[BB]] ]
; CHECK-NEXT:    [[D:%.*]] = phi ptr [ [[C]], [[BB1]] ], [ [[B]], [[BB]] ]
; CHECK-NEXT:    ret i8 [[DV]]
;
entry:
  br i1 %cond, label %bb, label %bb1

bb:
  store i8 4, ptr %b
  br label %bb2

bb1:
  store i8 92, ptr %c
  br label %bb2

bb2:
  %d = phi ptr [ %c, %bb1 ], [ %b, %bb ]
  %dv = load i8, ptr %d
  ret i8 %dv
}

define i32 @test3(i1 %cond, ptr %b, ptr %c) nounwind {
; CHECK-LABEL: define i32 @test3(
; CHECK-SAME: i1 [[COND:%.*]], ptr [[B:%.*]], ptr [[C:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[COND]], label [[BB:%.*]], label [[BB1:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    [[B1:%.*]] = getelementptr i32, ptr [[B]], i32 17
; CHECK-NEXT:    store i32 4, ptr [[B1]], align 4
; CHECK-NEXT:    br label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[C1:%.*]] = getelementptr i32, ptr [[C]], i32 7
; CHECK-NEXT:    store i32 82, ptr [[C1]], align 4
; CHECK-NEXT:    br label [[BB2]]
; CHECK:       bb2:
; CHECK-NEXT:    [[DV:%.*]] = phi i32 [ 82, [[BB1]] ], [ 4, [[BB]] ]
; CHECK-NEXT:    [[D:%.*]] = phi ptr [ [[C]], [[BB1]] ], [ [[B]], [[BB]] ]
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 7, [[BB1]] ], [ 17, [[BB]] ]
; CHECK-NEXT:    [[D1:%.*]] = getelementptr i32, ptr [[D]], i32 [[I]]
; CHECK-NEXT:    ret i32 [[DV]]
;
entry:
  br i1 %cond, label %bb, label %bb1

bb:
  %b1 = getelementptr i32, ptr %b, i32 17
  store i32 4, ptr %b1
  br label %bb2

bb1:
  %c1 = getelementptr i32, ptr %c, i32 7
  store i32 82, ptr %c1
  br label %bb2

bb2:
  %d = phi ptr [ %c, %bb1 ], [ %b, %bb ]
  %i = phi i32 [ 7, %bb1 ], [ 17, %bb ]
  %d1 = getelementptr i32, ptr %d, i32 %i
  %dv = load i32, ptr %d1
  ret i32 %dv
}

; PR5313
define i32 @test4(i1 %cond, ptr %b, ptr %c) nounwind {
; CHECK-LABEL: define i32 @test4(
; CHECK-SAME: i1 [[COND:%.*]], ptr [[B:%.*]], ptr [[C:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    br i1 [[COND]], label [[BB:%.*]], label [[BB1:%.*]]
; CHECK:       bb:
; CHECK-NEXT:    store i32 4, ptr [[B]], align 4
; CHECK-NEXT:    br label [[BB2:%.*]]
; CHECK:       bb1:
; CHECK-NEXT:    [[C1:%.*]] = getelementptr i32, ptr [[C]], i32 7
; CHECK-NEXT:    store i32 82, ptr [[C1]], align 4
; CHECK-NEXT:    br label [[BB2]]
; CHECK:       bb2:
; CHECK-NEXT:    [[DV:%.*]] = phi i32 [ 82, [[BB1]] ], [ 4, [[BB]] ]
; CHECK-NEXT:    [[D:%.*]] = phi ptr [ [[C]], [[BB1]] ], [ [[B]], [[BB]] ]
; CHECK-NEXT:    [[I:%.*]] = phi i32 [ 7, [[BB1]] ], [ 0, [[BB]] ]
; CHECK-NEXT:    [[D1:%.*]] = getelementptr i32, ptr [[D]], i32 [[I]]
; CHECK-NEXT:    ret i32 [[DV]]
;
entry:
  br i1 %cond, label %bb, label %bb1

bb:
  store i32 4, ptr %b
  br label %bb2

bb1:
  %c1 = getelementptr i32, ptr %c, i32 7
  store i32 82, ptr %c1
  br label %bb2

bb2:
  %d = phi ptr [ %c, %bb1 ], [ %b, %bb ]
  %i = phi i32 [ 7, %bb1 ], [ 0, %bb ]
  %d1 = getelementptr i32, ptr %d, i32 %i
  %dv = load i32, ptr %d1
  ret i32 %dv
}



; void test5(int N, ptr G) {
;   for (long j = 1; j < 1000; j++)
;     G[j] = G[j] + G[j-1];
; }
;
; Should compile into one load in the loop.
define void @test5(i32 %N, ptr nocapture %G) nounwind ssp {
; CHECK-LABEL: define void @test5(
; CHECK-SAME: i32 [[N:%.*]], ptr nocapture [[G:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:  bb.nph:
; CHECK-NEXT:    [[TMP7_PRE:%.*]] = load double, ptr [[G]], align 4
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.body:
; CHECK-NEXT:    [[TMP7:%.*]] = phi double [ [[TMP7_PRE]], [[BB_NPH:%.*]] ], [ [[ADD:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[INDVAR:%.*]] = phi i64 [ 0, [[BB_NPH]] ], [ [[TMP:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[ARRAYIDX6:%.*]] = getelementptr double, ptr [[G]], i64 [[INDVAR]]
; CHECK-NEXT:    [[TMP]] = add i64 [[INDVAR]], 1
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr double, ptr [[G]], i64 [[TMP]]
; CHECK-NEXT:    [[TMP3:%.*]] = load double, ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[ADD]] = fadd double [[TMP3]], [[TMP7]]
; CHECK-NEXT:    store double [[ADD]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[EXITCOND:%.*]] = icmp eq i64 [[TMP]], 999
; CHECK-NEXT:    br i1 [[EXITCOND]], label [[FOR_END:%.*]], label [[FOR_BODY]]
; CHECK:       for.end:
; CHECK-NEXT:    ret void
;
bb.nph:
  br label %for.body

for.body:
  %indvar = phi i64 [ 0, %bb.nph ], [ %tmp, %for.body ]
  %arrayidx6 = getelementptr double, ptr %G, i64 %indvar
  %tmp = add i64 %indvar, 1
  %arrayidx = getelementptr double, ptr %G, i64 %tmp
  %tmp3 = load double, ptr %arrayidx
  %tmp7 = load double, ptr %arrayidx6
  %add = fadd double %tmp3, %tmp7
  store double %add, ptr %arrayidx
  %exitcond = icmp eq i64 %tmp, 999
  br i1 %exitcond, label %for.end, label %for.body
for.end:
  ret void
}
